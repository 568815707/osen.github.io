<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>osenki</title>
  
  <subtitle>胆大，心细，不断努力。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="osenki.cn/"/>
  <updated>2017-12-19T16:17:16.636Z</updated>
  <id>osenki.cn/</id>
  
  <author>
    <name>osenki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈Qconf以及遇到的问题</title>
    <link href="osenki.cn/2017/12/20/%E6%B5%85%E8%B0%88Qconf%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>osenki.cn/2017/12/20/浅谈Qconf以及遇到的问题/</id>
    <published>2017-12-19T16:15:58.000Z</published>
    <updated>2017-12-19T16:17:16.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在项目中，因为 Qconf 出现了一些问题。于是瞎搞一通，创建了一些配置文件，改乱了一些系统权限。还好，自己都改回来了。对了，我这边是  OSX 系统的，并且是通过 NodeJs 进行的部署。</p></blockquote><p>1、什么是 Qconf：</p><pre><code>Qconf 是奇虎360广泛使用的配置管理服务。致力于将配置内容从代码中完全分离出来，及时可靠高效的提供配置访问和更新服务。</code></pre><p>2、为什么要用它：</p><pre><code>在我们开发的流程中，如果是分布式环境，那么几乎所有的服务都需要在不同的机器节点上部署多个实例，业务中总少不了各种类型的配置文件的，那么，我们有时候会根据业务的需求更改配置内容。所以我们还需要重新进行代码提交，打包，分发上线。如果有很多台机器要部署，分发上线会很麻烦。而配置文件的修改频率又远远大于代码本身。所以，我们需要一个对配置和代码的管理、发布管理系统。因此我们使用 Qconf （分布式配置管理系统）。</code></pre><p>3、Qconf 对配置的定位：</p><pre><code>-    单条数据量小-    更新频繁（较代码而言）-    配置总数可能巨大，但单台机器关心配置数有限-    读多写少</code></pre><p>4、使用方式：</p><pre><code>-     简单配置 公司内使用最广泛的用法，QConf非常适合经常需要变动的配置使用，如开关信息、版本信息、推荐信息、超时时间等。-     服务方式 这种方式多被服务提供者采用，如dba，系统部等，采用上述的服务配置的方式，通过QConf向公司的所有业务提供存储，计算及web服务。</code></pre><p>5、Qconf 安装：</p><pre><code>-    `git clone https://github.com/Qihoo360/QConf.git`-    `cd QConf &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake ..`-    如果 `cmake ..` 报错，那么直接在 `cmake ..` 一遍就行了-    `make`-    `make install`-    安装完成之后默认的路径是 /usr/local/qconf</code></pre><p>   Tips：在安装的过程中有可能会失败，其中有可能是由于使用权限（permissions）问题，那么我们直接在 <code>sudo -s</code> 下安装就行了。</p><p>6、 启动 Qconf</p><pre><code>-    `cd /usr/local/qconf`-    `cd bin &amp;&amp; sh qconf_agent.sh start`</code></pre><p>8、安装 node-qconf</p><pre><code>-    设置环境变量 `.bashrc/.zshrc/…`    `export QCONF_INSTALL=/usr/local/qconf-    `npm install node-qconf`</code></pre><p>7、遇到的一些问题：</p><pre><code> -    使用 Qconf 需要调整共享内存的限制，为什么修改呢？或许在你 `npm start` 项目时候会报错 `Failed to init qconf! ret:201` 。    通过 `sysctl -a | grep shm` 查看当前的共享内存上限的大小，如果不足 2G 那么进行下边的操作：    `sysctl kern.sysv.shmmax=2048000000`    `sysctl kern.sysv.shmall=1073741824`  Tips: 执行的时候有可能报权限（permissions）问题，直接在 `sudo -s` 下执行。        有的博客上在改动 `shmall` 的大小为 4294967296。这也没错，只不过不知道为什么，我的电脑设置这个值得时候，设置不成功，或许是我的共享内存页大小不够。所以我设置的值是在 Linux 下的共享内存限制。（linux 共享内存也的大小为4kb 所以除以 4 就行了）               -    在 `./agent-cmd.sh start` 提示 `./agent-cmd.sh: line 355: flock: command not found`     执行下边操作： -     cd /usr/local/qconf/bin -     vim agent-cmd.sh     -     :set number （vim编辑器会显示行数的） -     找到 355 行，将 flock 哪一行注释掉。保存退出即可</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在项目中，因为 Qconf 出现了一些问题。于是瞎搞一通，创建了一些配置文件，改乱了一些系统权限。还好，自己都改回来了。对了，我这边是  OSX 系统的，并且是通过 NodeJs 进行的部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、什么
      
    
    </summary>
    
      <category term="Qconf" scheme="osenki.cn/categories/Qconf/"/>
    
    
      <category term="Qconf" scheme="osenki.cn/tags/Qconf/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 部署失败问题</title>
    <link href="osenki.cn/2017/11/28/Hexo-%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>osenki.cn/2017/11/28/Hexo-部署失败问题/</id>
    <published>2017-11-28T12:55:08.000Z</published>
    <updated>2017-11-28T13:16:43.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天‘捯饬’博客，部署的时候出现一个自我感觉很奇葩的问题，在各大社区搜索也没有搜索到，话不多说上图片：</p></blockquote><p><img src="http://ow03felam.bkt.clouddn.com/LU0DP%5BL4H%25%297C6ISH@X~C9P.png" alt=""></p><p>看见这个问题的所在了吧，他竟然告诉我一个关于本地时间与服务器时间不对的问题。哎，我也是不懂了，为啥会出现这个问题。百度也不行，在各大社区 search 了一下也没有找到问题的所在之处。虽然图片上下文已经告诉我让我去哪里查解决问题的所在网址了，但是我查看以后，发现竟然都是关于 jekyll 搭建博客出现的问题解决方式。我当时就好无语。。（ps：难道就没有个关于 Hexo 的解决问题么！）</p><p>还是继续搜索下去吧，在 Stack Overflow 社区中有一篇文章吸引了我的注意力，其中回答者给出的一个答案是把一个文件删除了，然后重新部署。瞬间灵感来了，决定操作试一下。看下图：</p><p><img src="http://ow03felam.bkt.clouddn.com/%7BH%7D6XHOU8OU~F%29%7B2RF%25%259GY.png" alt=""> </p><p>我们直接把这个文件删除了！</p><p>然后执行代码 <code>hexo clean</code> -&gt; <code>hexo g</code> -&gt; <code>hexo s</code>(预览一下看看本地效果) -&gt; <code>hexo d</code> 。</p><p>好，奇迹发生了。部署成功啦。。是不是好开森。</p><p>一般其他的部署失败问题我就不说了，毕竟都能够通过度娘找到的，在度娘上找不到的也能在其他的社区找到答案的，好啦，开始你的 Hexo 之旅吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天‘捯饬’博客，部署的时候出现一个自我感觉很奇葩的问题，在各大社区搜索也没有搜索到，话不多说上图片：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ow03felam.bkt.clouddn.com/LU0DP%5B
      
    
    </summary>
    
      <category term="Hexo" scheme="osenki.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="osenki.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>parallax.js 轻量级视觉差引擎</title>
    <link href="osenki.cn/2017/10/21/parallax-js-%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%A7%86%E8%A7%89%E5%B7%AE%E5%BC%95%E6%93%8E/"/>
    <id>osenki.cn/2017/10/21/parallax-js-轻量级视觉差引擎/</id>
    <published>2017-10-21T15:29:26.000Z</published>
    <updated>2017-10-21T15:38:38.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多么炫酷的一个效果，对于移动端的支持也挺高的哦。废话不多说，开搞…</p></blockquote><p>首先呢，你要有这个脚本，下载地址：<a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="external">http://matthew.wagerfield.com/parallax/</a>  然后在你的 HTML 中引入就行了，这是最简单的方法喽。</p><p>【安装】</p><p>当然你也可以 这么安装： <code>npm i -s parallax-js</code></p><p>然后在你的 <code>node_modules/parallax-js/src/parallax.js</code> 中找到就行了。</p><p>【引用】</p><p>如果您使用从版本页面下载或从dist文件夹复制的编译版本，请像其他<code>JavaScript</code>库一样包含脚本：<br><code>&lt;script src=&quot;path/to/parallax.js&quot;&gt;&lt;/script&gt;</code><br>当然，当你通过<code>npm</code>安装并使用<code>browserify / babel</code>，你也可以简单地做：</p><p><code>import Parallax from &#39;parallax-js&#39;</code><br>或<br><code>const Parallax = require(&#39;parallax-js&#39;)</code></p><p>【使用】</p><pre><code>只需创建一个列表，给每个项目要内移动您的视差场景一类层和数据深度属性指定场景内的深度的元素。深度0，将导致层保持静止，深度为1，将导致层移动至所计算的运动的总效应。值插图中0和1，会造成层移动相对于所提供的比例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;scene&quot;&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.00&quot;&gt;&lt;img src=&quot;layer6.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.20&quot;&gt;&lt;img src=&quot;layer5.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.40&quot;&gt;&lt;img src=&quot;layer4.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.60&quot;&gt;&lt;img src=&quot;layer3.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.80&quot;&gt;&lt;img src=&quot;layer2.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;1.00&quot;&gt;&lt;img src=&quot;layer1.png&quot;&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></code></pre><p>如果你不用 <code>ul</code> 你也可以使用 <code>div</code> 作为容器哦，当然你的父容器 <code>id</code> 名一定要是 <code>scene</code> ，其子容器的 <code>class</code> 类名为 <code>layer</code> 。<code>data-depth</code> 代表着深度。这个属性一定要有哦。</p><p>视差场景，请选择您的父DOM元素，并把它传递给视差的构造函数。这个直接在你的 <code>scrip</code>t 标签中写就 ok 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var scene = document.getElementById(&apos;scene&apos;);</div><div class="line">var parallax = new Parallax(scene);</div></pre></td></tr></table></figure><p>【参数】</p><p>参数                                      值                                                 描述<br>relativeInput                         true 或false                 Specifies whether or not to use the coordinate system of the element passed to the parallax constructor. Mouse input only</p><p>clipRelativeInput                     true 或false                 Specifies whether or not to clip the mouse input to the bounds of the element passed to the parallax constructor. Mouse input only</p><p>calibrate-x                           true 或false                 指定是否根据初始时x轴的值来计算运动量</p><p>calibrate-y                           true 或false                 指定是否根据初始时y轴的值来计算运动量</p><p>invert-x                              true 或false                 设置为true则按反方向运动层</p><p>invert-y                              true 或false                 设置为true则按反方向运动层</p><p>limit-x                               number 或false               x方向上总的运动量数值范围，设置为false则允许层自由运动</p><p>limit-y                               number 或false               y方向上总的运动量数值范围，设置为false则允许层自由运动</p><p>scalar-x                              number                       输入的运动量和这个值相乘，增加或减少层运动的灵敏度</p><p>scalar-y                              number                       输入的运动量和这个值相乘，增加或减少层运动的灵敏度</p><p>friction-x                            number 0-1                   层运动的摩擦量，实际上是在层上添加一些easing效果</p><p>friction-y                            number 0-1                   层运动的摩擦量，实际上是在层上添加一些easing效果</p><p>origin-x                              number                       鼠标输入的x原点，默认值是0.5。0会移动原点到页面的左边，1会移动原点到页面的右边。Mouse input only</p><p>origin-y                              number                       鼠标输入的x原点，默认值是0.5。0会移动原点到页面的上边，1会移动原点到页面的下边。Mouse input only</p><p>当然在使用这些单数的前边要加 data-  哦！！</p><p>【使用参数例子】</p><p>行为：数据属性的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;scene&quot;</div><div class="line">  data-calibrate-x=&quot;false&quot;</div><div class="line">  data-calibrate-y=&quot;true&quot;</div><div class="line">  data-invert-x=&quot;false&quot;</div><div class="line">  data-invert-y=&quot;true&quot;</div><div class="line">  data-limit-x=&quot;false&quot;</div><div class="line">  data-limit-y=&quot;10&quot;</div><div class="line">  data-scalar-x=&quot;2&quot;</div><div class="line">  data-scalar-y=&quot;8&quot;</div><div class="line">  data-friction-x=&quot;0.2&quot;</div><div class="line">  data-friction-y=&quot;0.8&quot;&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.00&quot;&gt;&lt;img src=&quot;graphics/layer6.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.20&quot;&gt;&lt;img src=&quot;graphics/layer5.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.40&quot;&gt;&lt;img src=&quot;graphics/layer4.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.60&quot;&gt;&lt;img src=&quot;graphics/layer3.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;0.80&quot;&gt;&lt;img src=&quot;graphics/layer2.png&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;li class=&quot;layer&quot; data-depth=&quot;1.00&quot;&gt;&lt;img src=&quot;graphics/layer1.png&quot;&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><p>行为：构造函数对象实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var scene = document.getElementById(&apos;scene&apos;);</div><div class="line">var parallax = new Parallax(scene, &#123;</div><div class="line">  calibrateX: false,</div><div class="line">  calibrateY: true,</div><div class="line">  invertX: false,</div><div class="line">  invertY: true,</div><div class="line">  limitX: false,</div><div class="line">  limitY: 10,</div><div class="line">  scalarX: 2,</div><div class="line">  scalarY: 8,</div><div class="line">  frictionX: 0.2,</div><div class="line">  frictionY: 0.8</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>行为：API示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var scene = document.getElementById(&apos;scene&apos;);</div><div class="line">var parallax = new Parallax(scene);</div><div class="line">parallax.enable();</div><div class="line">parallax.disable();</div><div class="line">parallax.calibrate(false, true);</div><div class="line">parallax.invert(false, true);</div><div class="line">parallax.limit(false, 10);</div><div class="line">parallax.scalar(2, 8);</div><div class="line">parallax.friction(0.2, 0.8);</div></pre></td></tr></table></figure><p>jQuery的：传递选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$(&apos;#scene&apos;).parallax(&#123;</div><div class="line">  calibrateX: false,</div><div class="line">  calibrateY: true,</div><div class="line">  invertX: false,</div><div class="line">  invertY: true,</div><div class="line">  limitX: false,</div><div class="line">  limitY: 10,</div><div class="line">  scalarX: 2,</div><div class="line">  scalarY: 8,</div><div class="line">  frictionX: 0.2,</div><div class="line">  frictionY: 0.8</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>jQuery API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var $scene = $(&apos;#scene&apos;).parallax();</div><div class="line">$scene.parallax(&apos;enable&apos;);</div><div class="line">$scene.parallax(&apos;disable&apos;);</div><div class="line">$scene.parallax(&apos;calibrate&apos;, false, true);</div><div class="line">$scene.parallax(&apos;invert&apos;, false, true);</div><div class="line">$scene.parallax(&apos;limit&apos;, false, 10);</div><div class="line">$scene.parallax(&apos;scalar&apos;, 2, 8);</div><div class="line">$scene.parallax(&apos;friction&apos;, 0.2, 0.8);</div></pre></td></tr></table></figure><blockquote><p>就这些啦，欢快的使用吧。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多么炫酷的一个效果，对于移动端的支持也挺高的哦。废话不多说，开搞…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先呢，你要有这个脚本，下载地址：&lt;a href=&quot;http://matthew.wagerfield.com/parallax/&quot; ta
      
    
    </summary>
    
      <category term="各种插件" scheme="osenki.cn/categories/%E5%90%84%E7%A7%8D%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="parallax" scheme="osenki.cn/tags/parallax/"/>
    
  </entry>
  
  <entry>
    <title>首秀直播 App 感受分享</title>
    <link href="osenki.cn/2017/10/15/%E9%A6%96%E7%A7%80%E7%9B%B4%E6%92%AD-App-%E6%84%9F%E5%8F%97%E5%88%86%E4%BA%AB/"/>
    <id>osenki.cn/2017/10/15/首秀直播-App-感受分享/</id>
    <published>2017-10-15T14:41:21.000Z</published>
    <updated>2017-10-15T16:06:06.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本想着让自己的博客成为一个‘技术站’，想来想去还是想写一些自己的日常心迹，没有打错字，是心迹而不是心记。</p></blockquote><p>  【直播短絮】</p><p>  为什么这篇博文的 Title 叫做 ‘首秀直播 App 感受分享’ 呢？ 那是因为，目前我所在的公司就是一家互联网公司，是专门做社交软件的。也不怕大家说什么，公司做的业务方向是同志社交的 App。恩对，同志社交 App！</p><p>  日常中，自己也爱看一些其他的直播 App ，感觉那些网红为了礼物还是挺拼的，不过自己想想，他们也是为了生活，也是为了挣钱。毕竟都不容易么，那么拼，在直播间里各种秀。</p><p>  由于我司也是做相关的 App 的，虽然是做 Gay 的把，但是我也想体验一把做直播。于是就在我司 App 上申请了主播权限，申请的流程还不算太麻烦，第二天就申请通过了。（心里还有点小激动，wow.. 可以做主播了，没准还能红。哈哈..）</p><p>  哎呀，毕竟要做主播了，怎么着也得打扮打扮自己，于是乎，好好的整理了一下自己的发型（哈哈…），一切准备好了之后，开始主播。</p><p>  刚开始直播的 Ten minutes 中，并没有什么观众。（额，忘了说了，自己在直播的时候的 Title 是：新人直男直播喽。）毕竟使用我司的 App 都是 Gay 呢。所以我需要在自己直播间的 Title 上说明自己是直男，以免让其他的观众误认为我是 Gay。（hha…）。接下来的时间里，陆续来人了，慢慢的来了 300 多人，wow… 感觉人不少了，然后呢，发现进来的观众，还有我司的同事。（好尴尬，让他们发现我直播了，我可是直男诶。）虽然我开直播并不是为了得到礼物，但是我的同事们还是给我刷了礼物（获得礼物的时候好激动的）。其实呢，自己在直播的时候一直说话，跟观众互动，还要充分发挥出自己的口才，不然会导致直播间气氛尴尬的，因为观众们也是来看你说话或者表演来了，你在那干坐着，也不互动肯定是不行的。所以呢我就一直说话… 说得自己的嗓子好疼的。。自己也没有表演什么才艺之类的，就是只能说话了。想想那些网红，真的不容易，直播一次 1~2个小时的嗓子都受不了，毕竟我是第一次直播，所以在直播的时候我就一直喝水。hha…喝再多的水，也止不住我嗓子疼。</p><p>  【直播花絮】</p><p>  因为直播软件涉及到的群众方向问题，进来看直播的应该都是 Gay，其实聊天还是很正常的，只不过有一些思想上不同的，聊天的过程还是很好玩的。<br>  某观众：小哥哥，你是直男么？<br>  我：嗯呐，是的，我是直男。<br>  某观众：你长得挺像 Gay 的。<br>  我：额。。<br>  （话说，一开始我进我司的时候，大家也都认为我是 Gay 呢）<br>  某观众：你是像 Gay 的直男。<br>  我：额。。是的，我的长相还是像的。可我不是。<br>  某观众：小哥哥，喜欢你怎么办？你会弯么？<br>  我：嗯呐，不会的，我有女朋友的。<br>  …</p><blockquote><p>就这些吧，说的太多了，问的也太多了，具体的貌似说不完，毕竟我直播了可是长达了 2 个小时。还是那句话啊，嗓子疼。</p></blockquote><p>  【直播总结】</p><pre><code>1、直播挺累的。2、能成为网红的人真心不容易。3、重点是当网红也是要有才华的。4、自己公司的产品，多用用还是能够发现一些问题的。5、通过跟观众之间的互动，可以了解观众的一些需求，有利于自己对产品的改进。6、间接地了解到，其实他们 Gay 也听不容易的，不大众人认可。也不敢公开自己的喜爱。7、理解万岁吧，开心就好。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本想着让自己的博客成为一个‘技术站’，想来想去还是想写一些自己的日常心迹，没有打错字，是心迹而不是心记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  【直播短絮】&lt;/p&gt;
&lt;p&gt;  为什么这篇博文的 Title 叫做 ‘首秀直播 App 感受分享
      
    
    </summary>
    
      <category term="日常心迹" scheme="osenki.cn/categories/%E6%97%A5%E5%B8%B8%E5%BF%83%E8%BF%B9/"/>
    
    
      <category term="日常心迹" scheme="osenki.cn/tags/%E6%97%A5%E5%B8%B8%E5%BF%83%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Share to Facebook (javascript版)</title>
    <link href="osenki.cn/2017/10/15/Share-to-Facebook-javascript%E7%89%88/"/>
    <id>osenki.cn/2017/10/15/Share-to-Facebook-javascript版/</id>
    <published>2017-10-14T17:07:54.000Z</published>
    <updated>2017-10-14T17:15:13.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天水一篇，搞一下分享到 <code>Facebook</code>，其实有的时候我们并不会用到这个功能，但是看需求了，国人很多喜欢翻墙去看国外的网站，当然也有一部分人群会玩 <code>Facebook</code>（以下用 <code>FB</code> 来代替啦。）。<br>首先呢，介绍一下 <code>FB：Facebook</code>（原本称作thefacebook）是一家位于美国加州圣马特奥县门洛帕克市的在线社交网络服务网站。说白了他就是一个社交网站，有种类似微博。毕竟是国外的社交网站，所以我们要想使用 FB 或者 想要在 FB 上分享一些图文之类的，必须要翻墙了。<br>下面开始介绍如何分享到 FB 上。<br>废话不多说，直接上代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">  (function(d, s, id) &#123;</div><div class="line">    var js, fjs = d.getElementsByTagName(s)[0];</div><div class="line">    if (d.getElementById(id)) return;</div><div class="line">    js = d.createElement(s); js.id = id;</div><div class="line">    js.src = &quot;//connect.facebook.net/en_US/sdk.js&quot;;</div><div class="line">    fjs.parentNode.insertBefore(js, fjs);</div><div class="line">  &#125;(document, &apos;script&apos;, &apos;facebook-jssdk&apos;));</div><div class="line">  window.onload = function() &#123;</div><div class="line">    FB.init(&#123;</div><div class="line">      appId: ’ your-app-id &apos;,</div><div class="line">      autoLogAppEvents: true,</div><div class="line">      xfbml: true,</div><div class="line">      version: &apos;v2.10&apos;</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  document.getElementById(‘id&apos;).onclick = function() &#123;</div><div class="line">      FB.ui(&#123;</div><div class="line">        method: &apos;share&apos;,</div><div class="line">        mobile_iframe: true,</div><div class="line">        href: ‘ 你想要分享的网站 &apos;;,</div><div class="line">      &#125;, function(response)&#123;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>分别解释一下其中几个参数的意思：</p><p> <code>appId</code> : 你必须将 <code>your-app-id</code> 中的值替换为自己的 <code>Facebook</code> 开放平台应用的编号。您可以通过应用面板找到此编号。（这个一会下边我会给大家简单的示范一下。）</p><p><code>method</code>： 这个后边跟的参数是 分享 的意思，就是你要调用 <code>FB</code> 的 <code>share</code> 接口。（另外还有两种方式，我就不说了哈，我们只说分享。）</p><p><code>mobile_iframe: true</code>,  这个参数只能在移动端使用，如果这个参数为 <code>true</code> 的话，那么你在手机端使用的时候会从从手机顶端下滑一个 <code>iframe</code> ，这个 <code>iframe</code> 也就是你分享的一个弹出层。如图所示：</p><p><code>href</code>: ‘’, 这个后边跟的是你想要分享到 FB 上的网站链接。当然会在 上边的 <code>iframe</code> 面板中进行展示，并且别人也可以单击这个链接，跳转到你的网站中。<br>在 <code>FB.ui</code> 中可以添加的参数：</p><p>常用参数：<br><code>redirect_uri</code><br>  在用户点击对话框按钮后重定向的目标网址。使用网址重定向时必须提供。<br><code>display</code><br>  确定如何呈现对话框。</p><ul><li>如果使用网址重定向对话框实施方案，则对话框会在 Facebook.com 内全页显示。此显示类型被称为 <code>page</code>。</li><li>如果使用 <code>iOS</code> 版或 <code>Android</code> 版 <code>SDK</code> 调用对话框，则会自动指定此参数并为设备选择合适的显示类型。</li><li>如果使用 <code>JavaScript</code> 版 <code>Facebook SDK</code>：对于登录应用的用户，此参数默认为模式 <code>iframe</code> 类型；在 Facebook.com 中的游戏内使用时，此参数默认为 <code>async</code>；对于其他用户，此参数默认为 <code>popup</code> 窗口。使用 <code>JavaScript</code> 版 Facebook SDK 时，如有必要，还可以强制使用 popup 类型。</li><li>移动网页应用始终默认使用 <code>touch</code> 显示类型。</li></ul><p><code>share</code> 参数：<br><code>href</code><br>附加至此帖子的链接。使用 <code>share</code> 方法时必须提供。在此网址的页面上添加开放图谱元标签，自定义分享的动态。</p><p><code>hashtag</code><br>开发者指定的话题标签，将添加至分享内容中。用户可决定是否在分享对话框中移除这种话题标签。话题标签应包含 # 符号，例如 #facebook。</p><p><code>quote</code><br>将随分享的链接一同显示的引文，可由用户自行高亮选择，也可由开发者预先定义（例如文章的醒目引文）。</p><p><code>mobile_iframe</code><br>如果设置为 <code>true</code>，点击分享按钮后，您的网站顶部将在一个<code>iframe</code> 窗口中打开分享对话框（如需了解更多信息，请参阅移动网页分享对话框）。此选项仅适用于移动平台，不适用于桌面平台。</p><p>响应参数：<br><code>post_id</code><br>仅在用户通过 <code>Facebook</code> 登录您的应用并授予 <code>publish_actions</code> 时提供。如果存在，这是已发布的开放图谱动态的编号。<br><code>error_message</code><br>仅在用户通过 <code>Facebook</code> 登录来登录您的应用时提供。</p><p>更改语言：<br>假如你不想使用英文版的 <code>FB</code> 那么你可以更改语言啦。<br>在基本设置代码片段中将初始化 <code>en_US</code> 版本的 <code>SDK</code>，这意味着您网站上使用的所有 <code>Facebook</code> 品牌按钮和插件都将以美式英语显示。（但 Facebook 品牌的弹出对话框[例如：“登录”对话框]将以用户选择的 Facebook 界面语言显示，即使用户选择的语言与您选择的不同。）更改代码片段中的 js.src 值，即可更改此语言。<br>下面我们看一下如何获取到 ‘your-app-id’<br>首先你要打开这个网站：<a href="https://developers.facebook.com/apps" target="_blank" rel="external">https://developers.facebook.com/apps</a> （需要翻墙哦） 加入 FB 开发者行列 。网站上会有相关的步骤的哦，按照步骤来就行了，到时候会给你一个 <code>appid</code> 的，只要把这个 <code>appid</code> 输入到上边 <code>appId</code> 后边就行啦。<br>好啦，水完了。接下来会对 <code>FB</code> 其他的一些 SDK 进行研究，并且发博客哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天水一篇，搞一下分享到 &lt;code&gt;Facebook&lt;/code&gt;，其实有的时候我们并不会用到这个功能，但是看需求了，国人很多喜欢翻墙去看国外的网站，当然也有一部分人群会玩 &lt;code&gt;Facebook&lt;/code&gt;（以下用 &lt;code&gt;FB&lt;/
      
    
    </summary>
    
      <category term="Facebook SDK" scheme="osenki.cn/categories/Facebook-SDK/"/>
    
    
      <category term="Facebook" scheme="osenki.cn/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>React翻牌抽奖</title>
    <link href="osenki.cn/2017/09/22/React%E7%BF%BB%E7%89%8C%E6%8A%BD%E5%A5%96/"/>
    <id>osenki.cn/2017/09/22/React翻牌抽奖/</id>
    <published>2017-09-22T11:23:14.000Z</published>
    <updated>2017-09-22T11:32:08.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽奖活动的主要流程。（ps：移动端哦）</p></blockquote><p>1、前端控制翻牌效果。</p><p>2、服务端控制主要参数。</p><p>3、MySql存储信息。</p><p>在这里我只介绍步骤1了，也就是前端部分。如果童鞋们的公司分工明确的话，你们用到步骤1的部分就ok 了。</p><p><img src="http://ow03felam.bkt.clouddn.com/%E6%8A%BD%E5%A5%96%E6%95%88%E6%9E%9C.gif" alt="">                                        </p><p>首先呢，我强调一下，我做这个效果使用的框架是 <code>react</code> 框架。要想做到卡牌翻牌效果，首先你需要有两张图片，我们先说一下在用户未中奖的状态。一张翻牌的图片，一张未中奖的图片。前端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">constructor (props) &#123;</div><div class="line"></div><div class="line">  super(props)</div><div class="line"></div><div class="line">  this.state = &#123;</div><div class="line"></div><div class="line">    count: window.CONFIG.count,</div><div class="line"></div><div class="line">    haveGift: &apos;&apos;,</div><div class="line"></div><div class="line">    back: false</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  this.choice = this.choice.bind(this)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是我们的<code>constructor</code> 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">choice () &#123;</div><div class="line"></div><div class="line">     this.setState(&#123;back：true&#125;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是我们绑定的抽奖事件。</p><p><code>count</code> 代表抽奖的次数，这个 <code>count</code> 是我在服务端设置的并且挂在到了 <code>window.CONFIG</code>上，所以我们前端部分直接在 <code>window.CONFIG</code>上获取就行了。在服务端我设置了每人一次的抽奖机会。所以凡是打开该页面的人，都会拥有一次抽奖的机会。</p><p><code>haveGift</code> 代表获得礼物。服务端返回来的是一个值，前端把这个值对应上各自的礼物就行了。</p><p><code>back</code> 代表翻牌的效果值，初始给他一个 <code>false</code> 代表他为翻转，如果为 <code>true</code> 则为翻转之后的效果，我们通过绑定一个 <code>click</code> 事件来改变 <code>back</code> 的值，从而实现牌子的翻转效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;div className = ’show&apos;&gt;</div><div class="line"></div><div class="line">    &lt;div className = &#123;this.state.back ? &apos;flipped&apos; : &apos;&apos; &#125; onClick=&#123;this.choice&#125;&gt;</div><div class="line"></div><div class="line">        &lt;div className=&apos;front&apos;&gt;</div><div class="line"></div><div class="line">                        &lt;img src=&#123;require(`../img/raffle-win.png`)&#125;/&gt;</div><div class="line"></div><div class="line">                 &lt;/div&gt;</div><div class="line"></div><div class="line">        &lt;div className=&apos;front&apos;&gt;</div><div class="line"></div><div class="line">                        &lt;img src=&#123;require(`../img/raffle-lose.png`)&#125;/&gt;</div><div class="line"></div><div class="line">                 &lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>类名为 <code>.show</code> 的 div 将会用于制作3D空间， <code>.filpped</code> 的 div 作为3D对象的包装器，它里面有两个单独的 div 元素时卡片的正反两面。第二个 div 的类名使用了三元判断，相当于 <code>if..else..</code>语句。通过判断 <code>this.state.back</code> 的真假来调用不同的类名，当然 <code>flipped</code> 这个类就是会让卡牌翻转的类名。下面会有相应的 css 代码哦。</p><p>（如果你不想放入图片，你也可以在 div 里面输入文字来进行抽奖效果。按照抽奖的通常效果来说，如果中奖的话，会有提示，输入手机号之类的，从而进而领奖。当然你也可以在类名为<code>back</code> 的 div 中添加 <code>&lt;input&gt;</code> 输入框。自己脑洞打开，随你喽。）</p><p>下面我们为它们添加样式，首先给 3D 空间元素 <code>.show</code> 一个 相对定位方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.show&#123;</div><div class="line"></div><div class="line">  position: relative;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在我对网上的一些相关调查来看， 有的博文上说需要添加 <code>perspective</code> 属性，给他一个3D空间的大小，但是不知道为什么在我使用 React 框架中添加了这个属性之后反而不好使了。这确实是一个坑啊。如果其他童鞋用到的，你们可以尝试一下。看看行不行。 记得 <code>perspective</code> 要有兼容性的。</p><p>接下来我们用 <code>css3</code> <code>transitio</code>n 来添加一些过度效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.flipped&#123;</div><div class="line"></div><div class="line">  width: 100%;</div><div class="line"></div><div class="line">  height: 100%;</div><div class="line"></div><div class="line">  position: absolute;</div><div class="line"></div><div class="line">  transform-style: preserve-3d;</div><div class="line"></div><div class="line">  transition: transform 1s;</div><div class="line"></div><div class="line">  transform: rotateY( 180deg );</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>transform</code> 这三个属性，不懂得童鞋自行搜索喽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.front&#123;</div><div class="line"></div><div class="line">  height: 2.2rem;</div><div class="line"></div><div class="line">  display: block;</div><div class="line"></div><div class="line">  position: absolute;</div><div class="line"></div><div class="line">  width: 100%;</div><div class="line"></div><div class="line">  backface-visibility: hidden;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个是翻牌那一层 div</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.back&#123;</div><div class="line"></div><div class="line">  height: 2.2rem;</div><div class="line"></div><div class="line">  width: 100%;</div><div class="line"></div><div class="line">  display: block;</div><div class="line"></div><div class="line">  position: absolute;</div><div class="line"></div><div class="line">  backface-visibility: hidden;</div><div class="line"></div><div class="line">  transform: rotateY( 180deg );</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这是牌子下一层 div。</p><p>在 <code>HTML</code> 代码中特意设置了两个 div ，想一想哈，如果想通过一个div 实现翻转效果这个当然是很简单的啦，更换图片就行了。那我们中奖的效果呢？礼物有好多呢？总不能让 UI 给你做 N 张 多态图吧。显然是不可能的，所以就需要我们在服务端传入多种礼物值，然后在前端进行转换，在 div 中显示。这是其一。其二呢，目前大部分的抽奖翻牌效果都是，中奖后会出现一个弹框，让你输入领奖手机号之类的。如果再搞一个弹框，多麻烦。如果按照我这种设计方法呢，就不用加入弹框了。我们只需要在 <code>.back</code> 的 div 中添加一个<code>input</code> 输入框就行了。提交时我们仍然绑定上事件，把输入的值连接到 URL 上传给服务端。再通过服务端使用 SQL 语句将输入的值保存到数据库中。</p><p>好啦，到此我们前端的一个 react 框架抽奖效果就结束啦。如有疑问可以加我 qq ，联系我哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抽奖活动的主要流程。（ps：移动端哦）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、前端控制翻牌效果。&lt;/p&gt;
&lt;p&gt;2、服务端控制主要参数。&lt;/p&gt;
&lt;p&gt;3、MySql存储信息。&lt;/p&gt;
&lt;p&gt;在这里我只介绍步骤1了，也就是前端部分。如果童鞋
      
    
    </summary>
    
      <category term="React移动端" scheme="osenki.cn/categories/React%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="React" scheme="osenki.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>PWA(Progressive Web App)</title>
    <link href="osenki.cn/2017/09/09/PWA-Progressive-Web-App/"/>
    <id>osenki.cn/2017/09/09/PWA-Progressive-Web-App/</id>
    <published>2017-09-09T06:18:43.000Z</published>
    <updated>2017-09-25T16:57:56.378Z</updated>
    
    <content type="html"><![CDATA[<p>【 PWA 】</p><blockquote><p>今天开始 Research 一个新的前端技术，PWA（ 全称：Progressive Web App ）也就是说这是个渐进式的网页应用程序。这个技术的呢是 Google 公司于2015 年提出的，2016 年 6 月才推广的项目。针对这一项技术目前在国外似乎已经很流行了，目前应用这项技术最火热的应用是在印度（ 大家或许会疑惑为什么是在印度最流行呢吧，下文中会告诉大家哦 ），既然 PWA 这项技术在国外已经非常的流行了，那么在国内或许会不远了（ Angular 5 中新增的功能中，重点在于能够更轻松的构建渐进式网络应用程序，也就是 PWA 了。作为Google 和 mozilla 的产物，肯定会越来越重视啦 ）我引用一下关于PWA技术的一篇最早的博客文中的一句话吧： “ escaping tabs without losing our soul “（ 翻译一下哈：逃避选项卡而不丢失我们的灵魂 ）。</p></blockquote><p>官网上给出 PWA 的宣传是 ： <code>Reliable</code> （ 可靠的 ）、<code>Fast</code>（ 快速的 ）、<code>Engaging</code>（ 可参与的 ）（ 官网：<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">https://developers.google.com/web/progressive-web-apps/</a> ps：需要翻墙哦  ）。简单的说一下这三个特性：</p><p> <code>Reliable</code> ： 为什么他是可靠的呢，当用户从手机主屏幕启动时，不用考虑网络的状态是如何，都可以立刻加载出 PWA。<br> <img src="https://static.oschina.net/uploads/space/2017/0824/162357_s0qX_3125199.png" alt="">    </p><p> <code>Fast</code>：这一点应该都很熟悉了吧，站在用户的角度来考虑，如果一个网页加载速度有点长的话，那么我们会放弃浏览该网站，所以 PWA 在这一点上做的很好，他的加载速度是很快的。<br> <img src="https://static.oschina.net/uploads/space/2017/0824/162357_VTyB_3125199.png" alt=""></p><p> <code>Engaging</code> ： PWA 可以添加在用户的主屏幕上，不用从应用商店进行下载（ 似乎省了下载流量哦！）他们通过网络应用程序 <code>Manifest file</code> 提供类似于 APP 的使用体验（ 在 Android 上可以设置全屏显示哦，由于 Safari 支持度的问题，所以在 IOS 上并不可以 ），并且还能进行 ”推送通知” 。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_bR5z_3125199.png" alt=""><br> 这三个主特性似乎能解释我在前言中所说的 ”在印度最流行“ 。小小的普及一下，根据2016年第三季度的 IDC统计数据显示，印度的智能手机的出货量达到了3亿，同时也超过了美国，成为了全球第二大智能手机市场。皮尤斯数据报告 2015 年曾统计过“全球智能手机拥有率”。印度只有 17% 的人口用的是智能手机。虽然绝大部分人有手机用，但为非智能机，另有 22% 的人没有手机。针对印度的移动网络流量来说，网络状况是非常不佳的，根据16年的 GSMA 印度移动经济报告显示，网络覆盖率为34.8% 。主要集中在城镇，印度广大的农村还处于网络盲区，城乡数字化鸿沟很大。在印度，2G/3G 最主流，且 2G 占比还远高于 3G ， 所以针对这种状态来说，PWA 技术最适合不过了。</p><p> 在我对 PWA 技术的研究中发现 PWA 其中有三个关键的技术：</p><ul><li><code>Service Worker</code>（ ps：就叫做服务工厂吧，文章最后一条 URL 是 SW 的全面进阶，可以研究研究哦 ）</li><li><code>Manifest</code> （应用清单）</li><li><code>Push Notification</code>（推送通知）</li></ul><blockquote><p>下面我一一介绍着三个关键的技术：</p></blockquote><p><code>Service Worker</code>（ 以下用SW来代替 ） ：</p><p>SW 是什么呢？这个是离线缓存文件。我们 PWA 技术使用的就是它！SW 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门，因为使用了它，才会有的那个 <code>Reliable</code> 特性吧，SW 作用于 浏览器于服务器之间，相当于一个代理服务器（ 用一张图来表示一下他的位置 ）。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_kB7y_3125199.png" alt=""></p><p>为什么会用到 SW 呢？原声 App 拥有Web应用通常所不具备的富离线体验，定时默认更新，消息推送等功能，而 SW 标准让在 Web App 上拥有这些功能成为可能！</p><p>跟 SW 相同的 API 还有 <code>App Cache</code> ，为什么不使用它呢？ <code>App Cache</code> 是有局限性的，比如说：它很容易得解决 <code>single web page application</code> （ 单页面应用 ）的问题，但是在多页面应用上会很麻烦， SW 解决的这个 <code>App Cache</code>的缺点！</p><p> 下面我简单而详细的说一下 SW ：<br> 1、 浏览器支持<br>    目前浏览器的支持度还不是很高。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_U9n4_3125199.png" alt=""></p><blockquote><p>顺便带一句：目前只能在 HTTPS 环境下才能使用SW，因为SW 的权利比较大，能够直接截取和返回用户的请求，所以要考虑一下安全性问题。</p></blockquote><p>2、事件机制<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_Z4cS_3125199.png" alt=""><br>3、 功能</p><blockquote><p>SW的功能还是比较逆天的！</p></blockquote><ul><li>后台数据的同步</li><li>从其他域获取资源请求</li><li>接受计算密集型数据的更新，多页面共享该数据</li><li>客户端编译与依赖管理</li><li>后端服务的hook机制</li><li>根据URL模式，自定义模板</li><li>性能优化</li><li>消息推送</li><li>定时默认更新</li><li>地理围栏</li></ul><p>4、 生命周期<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_lqqQ_3125199.png" alt=""><br><code>Parsed</code> （ 解析成功 ）： 首次注册 SW 时，浏览器解决脚本并获得入口点，如果解析成功，就可以访问到 SW 注册对象，在这一点中我们需要在 HTML 页面中添加一个判断，判断该浏览器是否支持 SW 。</p><p><code>Installing</code> （ 正在安装 ）：SW 脚本解析完成之后，浏览器会尝试进行安装，<code>installing</code> 中 <code>install</code> 事件被执行，如果其中有 <code>event.waitUntil ( )</code>方法，则 <code>installing</code> 事件会一直等到该方法中的 <code>Promise</code> 完成之后才会成功，如果 <code>Promise</code> 被拒绝，则安装失败，SW会进入 <code>Redundant</code>（ 废弃 ）状态。</p><p><code>Installed / Waiting</code> （安装成功/等待中）：如果安装成功，SW 将会进入这个状态。</p><p><code>Activating</code> （ 正在激活 ）：处于 waiting 状态的 SW 发生以下情况，将会进入 activating 状态中：</p><p>当前已无激活状态的 <code>worker</code> 、 SW脚本中的 <code>self.skipWaiting（）</code>方法被调用 （ <em>ps： self 是 SW 中作用于全局的对象，这个方法根据英文翻译过来也能明白什么意思啦，跳过等待状态</em> ）、用户已关闭 SW 作用域下的所有页面，从而释放了当前处于激活状态的 <code>worker</code>、超出指定时间，从而释放当前处于激活状态的 <code>worker</code></p><p><code>Activated</code> （ 激活成功 ）：该状态，其成功接收了 <code>document</code> 全面控制的激活态 <code>worker</code> 。</p><p><code>Redundant</code> （ 废弃 ）：这个状态的出现时有原因的，如果 <code>installing</code> 事件失败或者 <code>activating</code> 事件失败或者新的 SW 替换其成为激活态 <code>worker</code> 。<code>installing</code> 事件失败和 <code>activating</code> 事件失败的信息我们可以在 <code>Chrome</code> 浏览器的 <code>DevTools</code> 中查看.<br>            （ ps：我这个是正常的状态下的 ，错误的话会有 error 提示的）<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_bBN5_3125199.png" alt=""></p><p>5、主要依赖</p><p>SW 作为现代浏览器的高级特性，依赖于 <code>fetch</code> 、<code>promise</code> 、<code>CacheStorage</code>、<code>Cache</code>、等浏览器的基础能力， <code>Cache</code> 提供了 <code>Request</code> / <code>Response</code> 对象对的存储机制。<code>CacheStorage</code> 则提供了存储 <code>Cache</code> 对象的机制。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_nmwE_3125199.png" alt="">  </p><p>6、安全性问题</p><p>跨域请求支持：  SW 可以拦截它作用域内的所有请求，跨域资源也不例外，但是浏览器默认对跨域资源发起的是 <code>no-cors</code> 请求，得到的 <code>response</code> 是 <code>opaque</code> 的， 所以会导致我们无法判断跨域请求是否成功，以便进行缓存，因此我们需要修改 <code>fetch</code> 请求头部信息，添加 <code>mode：’cors’</code> 标记。</p><p>（ 名词解释一下喽，这部分知识是关于 <code>fetch API</code> 的，想了解更多的同学，自行搜索相关的知识哈 ）</p><p><code>no-cors</code>：该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 <code>method</code> 只能是 <code>HEAD</code> 、<code>GET</code> 、<code>POST</code> 。此外，如果 <code>ServiceWorkers</code> 拦截了这些请求，它不能随意添加或者修改除这些之外 <code>Header</code> 属性。第三，JS 不能访问 <code>Response</code> 对象中的任何属性，这确保了跨域时 <code>ServiceWorkers</code> 的安全和隐私信息泄漏问题。</p><p><code>opaque</code>：<code>Response</code> 对象中 <code>type</code> 属性的值 ， 在 <code>no-cors</code> 模式下请求了跨域资源，依靠服务端来做限制。</p><blockquote><p>Manifest （ 应用清单 ）</p></blockquote><p>Web App Manifest 是一个 W3C 规范，它定义了一个基于 JSON 的 List 。Manifest 在 PWA 中的作用有：</p><ul><li>能够将你浏览的网页添加到你的手机屏幕上</li><li>在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）</li><li>控制屏幕 横屏 / 竖屏 展示</li><li>定义启动画面</li><li>可以设置你的应用启动是从主屏幕启动还是从 URL 启动</li><li>可以设置你添加屏幕上的应用程序图标、名字、图标大小</li><li>Push Notification （ 消息通知 ）</li><li>Push 和 Notification 是两个不同的功能，涉及到两个 API 。</li><li>Notification 是浏览器发出的通知消息。</li><li>Push 和 Notification 的关系，Push：服务器端将更新的信息传递给 SW ，Notification： SW 将更新的信息推送给用户。</li></ul><p>缺点：</p><ul><li>浏览器的支持度问题，尤其是 Safari 浏览器，这样就会导致我们在 IOS 系统手机上没办法体验 PWA 。（ 谁让 ‘ 果果 ’ 不是开源的呢 ）</li><li>根据国情来看哈，目前 Native App 的使用用户都已经习惯了，虽然会下载一下，但是现在 WiFi 到处都是了，毕竟 WiFi 的普及太快了。让用户使用 PWA 来替代 Native App 短时间会不适应的。</li><li>消息推送问题，PWA的消息推送走的是 GCM（ FCM ）通道。而国内 Google 是无法访问的。（只能翻墙了，但是工信部已经禁止使用 VPN 了。）</li></ul><p>总体来说：</p><p>Google 的技术在国内推进比较缓慢，所以 PWA 在国内的发展是有多困难吧。</p><p>【 Demo 】<br>首先呢，我们用到有 Node 和 Ngrok 。Node 的使用以及安装我就不说啦，作为一名前端开发工程师肯定会使用的啦。不会使用也米有关系啦，我们有度娘呢，Ngrok 的安装以及使用我就直接共享一个URl吧：<a href="http://blog.csdn.net/tomcat_2014/article/details/68944066（" target="_blank" rel="external">http://blog.csdn.net/tomcat_2014/article/details/68944066（</a> <em>ps：我就偷懒一下</em> ）</p><ul><li>我们先创建一个关于 PWA 的项目文件夹，</li><li>进入文件夹下我们准备一张 120x120的图片一张，作为我们的应用程序图标。</li><li>创建一个 index.html  文件</li><li>创建一个 index.css 文件</li><li>创建一个 manifest.json 文件</li><li>创建一个 sw.js 文件</li><li>利用终端，安装一下 http-server 服务</li></ul><p>index.html<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_0MDP_3125199.png" alt=""></p><p>index.css<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_L9vM_3125199.png" alt=""></p><blockquote><p>manifest.json中的一些参数的简单的介绍</p></blockquote><p>short_name: “ “ 用户主屏幕上的应用名字</p><p>display : “standalone”  设置启动样式，让您的网络应用隐藏浏览器的 URL 地址栏</p><p>start_url : “/“ 设置启动网址，如果不提供的话，默认是使用当前页面</p><p>theme_color : “ “  用来告知浏览器用什么颜色来为地址栏等 UI 元素着色</p><p>background_color: “ ” 设置启动页面的背景颜色</p><p>icons：””  就是添加到主屏幕之后的图标<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_oDGM_3125199.png" alt=""></p><p>sw.js</p><p>处理静态缓存，首先定义需要缓存的路径，以及需要缓存的静态文件的列表。</p><p>借助 SW 注册完成安装 SW 时，抓取资源写入缓存中。使用了一个方法那就是 <code>self.skipWaiting( )</code> 这个方法我在前边介绍的时候也说了，为了在页面更新的过程当中，新的 SW 脚本能够立刻激活和生效。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_N2eL_3125199.png" alt=""></p><p>处理动态缓存，我们监听 <code>fetch 事件</code>，在 <code>caches</code> 中去 <code>match</code> 事件的 <code>request</code> ，如果 <code>response</code> 不为空的话就返回 <code>response</code> ，最后返回 <code>fetch</code> 请求，在 <code>fetch</code> 事件中我们可以手动生成 <code>response</code> 返回给页面。</p><p>更新静态资源，缓存的资源会跟随着版本的更新会过期的，所以会根据缓存的字符串名称清除旧缓存。在新安装的 SW 中通过调用 <code>self.clients.claim( )</code> 取得页面的控制权，这样之后打开页面都会使用版本更新的缓存。旧的 SW 脚本不在控制着页面之后会被停止，也就是会进入 <code>Redundant</code> 期。</p><p><img src="https://static.oschina.net/uploads/space/2017/0824/162358_iejq_3125199.png" alt=""></p><p> 以上截图中最左侧是我文件下的列表喽，下面我们来运行一下，终端启动 http-server 服务，我们以关闭缓存的方式进行启动。<br> <img src="https://static.oschina.net/uploads/space/2017/0824/162357_cBdU_3125199.png" alt=""></p><p>接下来我们使用 ngrok 这个工具，进行内网穿透。在上边启动 http-server 服务的时候我们使用默认的端口号 8080 。所以我们在 ngrok 中我们绑定 端口 8080 。输入命令 ： ./ngrok http 8080 之后我们看一下。（记得再打开一个终端哦，在另一个终端中进行操作）<br><img src="https://static.oschina.net/uploads/space/2017/0824/162357_YyvC_3125199.png" alt=""></p><p>我们看到绿色的字母 online 表示内网穿透成功了，我们看最后一个 <em>Forwarding     https://</em> 的，因为我们在上边介绍了，SW 的权利比较大，为了保证信息的安全性，我们使用 https 协议来进行访问。我们把它复制下来在 chrom 浏览器中打开，-&gt; 符号后边的就不用复制了哈。（ <em>每个人的 ‘隧道’ 都是不一样的哦，这一点同学们可以在 ngrok 官网中进行查询哦</em> ）。</p><p>我们打开 chrom 的调试工具，打开 application ，点击 service workers 之后我们会发现 sw.js 脚本已经存到了 SW 中 。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162358_t95c_3125199.png" alt=""></p><p>我们打开 Network 刷新页面一下，看看，我们的页面资源来自 SW 而不是其他的地方，在 Console 中也打印出了我们在 index.html 中判断的语句，浏览器支持就会打印出这一句话哦。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162358_KTLf_3125199.png" alt=""></p><p>接下来我们断网操作，在 <code>Application</code> 中给 <code>Offline</code> 打上对勾就行啦。然后刷新页面，我们仍然能看到之前的页面，原因就是我们在上图看到，他的资源是从 SW 上获得到的。当我们第一次打开这个页面的时候，<code>Resopnse</code> 对象被存到了 <code>Cache Storage</code> （ 定义在 SW 规范中 ，相关资料请同学们自行查询啦 ）中。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162358_KhRc_3125199.png" alt=""></p><p>通过存放到 <code>Cache Storage</code> 中，我们下次访问的时候如果是弱网或者断网的情况下，就可以不走网络请求，而直接就能将本地缓存的内容展示给用户，优化用户的弱网及断网体验。</p><p>这个时候肯定会有同学在想，如果内容更新了，那么页面展示的内容是新内容呢还是旧内容呢？下面我们操作一下，打开 <code>index.html</code> 文件，我们在 <code>body</code> 中添加一个 <code>p</code> 标签 ，然后回到页面刷新。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162358_Fckh_3125199.png" alt=""></p><p><img src="https://static.oschina.net/uploads/space/2017/0824/162358_Nj8t_3125199.png" alt=""></p><p>我们看到，页面上的内容并没有显示出我刚刚添加的那个 <code>p</code> 标签。这说明了，我们拿到的数据还是从 <code>Cache Storage</code> 中获取到的，<code>Cache Storage</code>中的内容并没有更新，那么我们怎么才能让我刚刚添加的那个 <code>p</code> 标签显示出来呢。</p><p>我们打开 sw.js 脚本文件，我们修改一下 cacheStorageKey。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162359_jR85_3125199.png" alt=""></p><p>我们关闭一下浏览器，然后再次打开该网址，页面出现了我们刚刚添加的那个 <code>p</code> 标签。我们再看一下 <code>Cache Storage</code> 中的缓存名字，已经被修改。<br><img src="https://static.oschina.net/uploads/space/2017/0824/162358_m9Li_3125199.png" alt=""></p><p>【 总结 】</p><p>在研究这个 PWA 的过程中，搜索了相关的一大部分知识，就怕自己的脑洞不够大。感觉 PWA 涉及到的 API 比较多。要想研究透彻 PWA 还需要研究它所涉及到的 API ，慢慢研究吧。<code>npm</code> 中已经有这个包了哦。想真实的对 PWA 做深入研究的同学，可以应用到实际项目中。（ 我感觉，会有很多坑 ）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【 PWA 】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天开始 Research 一个新的前端技术，PWA（ 全称：Progressive Web App ）也就是说这是个渐进式的网页应用程序。这个技术的呢是 Google 公司于2015 年提出的，2016 年 6 月才
      
    
    </summary>
    
      <category term="前瞻技术" scheme="osenki.cn/categories/%E5%89%8D%E7%9E%BB%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="PWA(Progressive Web App)" scheme="osenki.cn/tags/PWA-Progressive-Web-App/"/>
    
  </entry>
  
</feed>
